>>>>>>>.gitignore
node_modules
*.mp4
stats
.DS_Store
>>>>>>>INSTALL.md
# Guia de Solu√ß√£o de Problemas do Cloudflared

Este guia ajudar√° voc√™ a diagnosticar e resolver problemas espec√≠ficos com o Cloudflared que podem estar causando travamentos no seu script de compartilhamento de v√≠deo.

## Problemas Comuns e Solu√ß√µes

### 1. O Cloudflared n√£o consegue iniciar o t√∫nel

**Sintomas:**
- Mensagem "Iniciando t√∫nel Cloudflare..." aparece, mas nunca conclui
- Nenhuma URL √© gerada
- N√£o h√° mensagens claras de erro

**Poss√≠veis causas e solu√ß√µes:**

#### Vers√£o desatualizada do Cloudflared
```bash
# Verifique a vers√£o
cloudflared --version

# Atualize para a vers√£o mais recente
# No macOS
brew upgrade cloudflared

# No Linux (usando pacotes .deb)
curl -L https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64.deb -o cloudflared.deb
sudo dpkg -i cloudflared.deb
```

#### Conflito com t√∫neis anteriores
Pode haver t√∫neis antigos do Cloudflared ainda em execu√ß√£o:

```bash
# Encerre todos os processos do Cloudflared
# No Linux/Mac
pkill -f cloudflared

# No Windows
taskkill /F /IM cloudflared.exe
```

#### Problemas de permiss√£o
O Cloudflared pode n√£o ter permiss√µes para estabelecer a conex√£o:

```bash
# No Linux/Mac, tente executar como sudo
sudo cloudflared tunnel --url http://localhost:3000

# Verifique se a pasta .cloudflared em sua home tem permiss√µes corretas
ls -la ~/.cloudflared
```

### 2. O t√∫nel inicia mas cai depois de alguns segundos

**Sintomas:**
- A URL √© gerada, mas logo em seguida o t√∫nel √© encerrado
- Mensagens de erro como "tunnel error" ou "connection reset"

**Poss√≠veis causas e solu√ß√µes:**

#### Firewall ou VPN bloqueando a conex√£o
- Desative temporariamente firewalls ou VPNs
- Verifique se a porta 443 (HTTPS) n√£o est√° bloqueada para sa√≠da
- Se estiver em rede corporativa, consulte o administrador de rede

#### Problemas com o protocolo utilizado
Tente for√ßar um protocolo espec√≠fico:

```bash
cloudflared tunnel --url http://localhost:3000 --protocol quic
# ou
cloudflared tunnel --url http://localhost:3000 --protocol h2mux
```

#### Servidor local n√£o est√° respondendo corretamente
Verifique se o servidor Express est√° funcionando:
```bash
curl http://localhost:3000 -I
```

### 3. Problemas de DNS ou de Resolu√ß√£o de Nome

**Sintomas:**
- Erro relacionado a DNS ou resolu√ß√£o de nome
- Mensagens como "could not resolve host"

**Solu√ß√µes:**
- Tente usar servidores DNS p√∫blicos:
  ```bash
  # No Linux, edite /etc/resolv.conf temporariamente
  echo "nameserver 8.8.8.8" | sudo tee /etc/resolv.conf
  echo "nameserver 1.1.1.1" | sudo tee -a /etc/resolv.conf
  ```

- Em caso de problemas persistentes, tente o m√©todo alternativo com um arquivo de configura√ß√£o:
  ```bash
  # Crie um arquivo de configura√ß√£o
  echo "tunnel: true" > config.yml
  echo "url: http://localhost:3000" >> config.yml
  echo "logfile: tunnel.log" >> config.yml
  
  # Use o arquivo de configura√ß√£o
  cloudflared tunnel --config config.yml
  ```

### 4. Rastreando o Problema com Logs Detalhados

Para identificar exatamente o que est√° ocorrendo:

```bash
# Crie um log detalhado do cloudflared
cloudflared tunnel --url http://localhost:3000 --loglevel debug > cloudflared.log 2>&1
```

Analise o arquivo cloudflared.log para mensagens como:
- "connection refused" (problema com o servidor local)
- "certificate" (problema com certificados)
- "timeout" (problema de rede)
- "rate limit" (limite de uso do Cloudflare)

### 5. M√©todos Alternativos de Compartilhamento

Se o Cloudflared continuar apresentando problemas, considere estas alternativas:

#### Ngrok (similar ao Cloudflared)
```bash
# Instalar Ngrok
npm install -g ngrok

# Usar Ngrok para expor o servidor
ngrok http 3000
```

#### LocalTunnel
```bash
# Instalar localtunnel
npm install -g localtunnel

# Usar localtunnel para expor o servidor
lt --port 3000
```

## Verifica√ß√£o Passo a Passo

Se voc√™ est√° com dificuldades para diagnosticar o problema:

1. **Verifique o servidor local**
   ```bash
   # Inicie apenas o servidor Express
   node -e "require('express')().get('/',(q,s)=>s.send('OK')).listen(3000,()=>console.log('OK'))"
   
   # Em outro terminal, confirme se est√° respondendo
   curl http://localhost:3000
   ```

2. **Verifique o Cloudflared isoladamente**
   ```bash
   # Teste o cloudflared com um servidor simples
   cloudflared tunnel --url http://localhost:3000
   ```

3. **Verifique sua conex√£o com servidores Cloudflare**
   ```bash
   # Ping para verificar a conectividade b√°sica
   ping one.one.one.one
   
   # Teste mais profundo usando TCP
   nc -vz one.one.one.one 443
   ```

Lembre-se que, por ser um servi√ßo gratuito, o Cloudflared pode ocasionalmente apresentar problemas tempor√°rios. Se nada mais funcionar, aguarde algumas horas e tente novamente.
>>>>>>>README.MD
# Instru√ß√µes para o Video-Share-Debug.js

Este script aprimorado resolve problemas com o Cloudflare Tunnel e adiciona logs de depura√ß√£o para ajudar a identificar o que est√° acontecendo quando o t√∫nel trava.

## Pr√©-requisitos

- Node.js (vers√£o 14+)
- Cloudflared instalado
- As depend√™ncias do projeto original

## Instala√ß√£o

1. Salve o arquivo `video-share-debug.js` no mesmo diret√≥rio do projeto original

2. Verifique se as depend√™ncias est√£o instaladas:
   ```bash
   npm install
   ```

## Uso

Execute o script passando o caminho do v√≠deo e, opcionalmente, uma mensagem personalizada:

```bash
node video-share-debug.js /caminho/para/seu/video.mp4 "Feliz P√°scoa, filha! Estou com saudades, te amo muito!"
```

## Novos recursos de depura√ß√£o

Este script aprimorado inclui:

1. **Logs detalhados**: Mostra exatamente o que est√° acontecendo com o processo do Cloudflared
2. **Detec√ß√£o de falhas**: Identifica quando o t√∫nel Cloudflare trava
3. **M√©todo alternativo de t√∫nel**: Tenta um m√©todo diferente se o padr√£o falhar
4. **Melhor encerramento de processos**: Garante que todos os processos sejam encerrados corretamente
5. **Tratamento de erros aprimorado**: Captura e registra erros para ajudar na solu√ß√£o de problemas
6. **Timeout com sugest√µes**: Se n√£o conseguir URL em 60 segundos, mostra sugest√µes √∫teis

## Solucionando problemas comuns do Cloudflared

Se o t√∫nel continuar travando:

1. **Verifique a vers√£o do Cloudflared**:
   ```bash
   cloudflared --version
   ```
   Atualize para a vers√£o mais recente se necess√°rio.

2. **Execute o Cloudflared manualmente para ver mensagens de erro**:
   ```bash
   cloudflared tunnel --url http://localhost:3000 --verbose
   ```

3. **Verifique sua conex√£o de internet**:
   Certifique-se de que sua conex√£o seja est√°vel e que n√£o esteja atr√°s de um firewall restritivo.

4. **Verifique se h√° processos do Cloudflared travados**:
   ```bash
   # No Linux/Mac
   ps aux | grep cloudflared
   
   # No Windows
   tasklist | findstr cloudflared
   ```
   
   Se encontrar processos antigos, encerre-os:
   ```bash
   # Linux/Mac
   pkill -f cloudflared
   
   # Windows
   taskkill /F /IM cloudflared.exe
   ```

5. **Alternativa: Use o m√©todo alternativo diretamente**:
   ```bash
   node video-share-debug.js /caminho/do/seu/video.mp4 "Sua mensagem" --alt-tunnel
   ```

## Entendendo os logs de depura√ß√£o

O script gera logs com prefixo `[DEBUG]` que mostram:

- Inicializa√ß√£o e configura√ß√£o do servidor
- Tentativas de conex√£o do Cloudflared
- Atividade do cliente (visualiza√ß√µes, pausas, etc.)
- Erros e exce√ß√µes

Se precisar compartilhar esses logs para obter ajuda, voc√™ pode redirecion√°-los para um arquivo:

```bash
node video-share-debug.js /caminho/do/seu/video.mp4 "Sua mensagem" > debug_log.txt 2>&1
```

## Considera√ß√µes de seguran√ßa

- O script exp√µe uma porta local (3000) para a internet atrav√©s do Cloudflare
- A URL gerada √© tempor√°ria e v√°lida apenas enquanto o script estiver em execu√ß√£o
- As estat√≠sticas de acesso s√£o armazenadas localmente em `stats/access_stats.json`
>>>>>>>package.json
{
  "name": "video-share-stats",
  "version": "1.0.0",
  "description": "Compartilhe v√≠deos facilmente com estat√≠sticas de visualiza√ß√£o",
  "main": "video-share.js",
  "bin": {
    "video-share": "./video-share.js"
  },
  "scripts": {
    "start": "node video-share.js"
  },
  "dependencies": {
    "express": "^4.18.2",
    "mime-types": "^2.1.35",
    "qrcode-terminal": "^0.12.0"
  }
}
>>>>>>>share-video.sh
#!/bin/bash

# Script para manter o servidor de v√≠deo rodando no Mac
# Mesmo quando voc√™ fechar o terminal ou fizer logout

# Verificar argumentos
if [ -z "$1" ]; then
  echo -e "\n‚ùå Erro: Arquivo de v√≠deo n√£o especificado"
  echo -e "\nUso: ./run-on-mac.sh /caminho/para/arquivo.mp4 [mensagem personalizada]"
  echo -e "Exemplo: ./run-on-mac.sh ~/Videos/pascoa.mp4 \"Feliz P√°scoa, filha! Com amor, papai.\"\n"
  exit 1
fi

# Obter caminho completo do v√≠deo
VIDEO_PATH=$(realpath "$1")

# Mensagem personalizada (opcional)
MESSAGE="$2"

# Verificar se o arquivo existe
if [ ! -f "$VIDEO_PATH" ]; then
  echo -e "\n‚ùå Erro: O arquivo '$VIDEO_PATH' n√£o foi encontrado"
  exit 1
fi

# Diret√≥rio onde o script est√°
SCRIPT_DIR=$(dirname "$0")
cd "$SCRIPT_DIR"

# Verificar se as depend√™ncias est√£o instaladas
if ! command -v node &> /dev/null; then
    echo "‚ùå Node.js n√£o encontrado. Por favor, instale com 'brew install node'"
    exit 1
fi

if ! command -v npm &> /dev/null; then
    echo "‚ùå npm n√£o encontrado. Instale o Node.js completo com 'brew install node'"
    exit 1
fi

if ! command -v cloudflared &> /dev/null; then
    echo "‚ùå Cloudflared n√£o encontrado. Por favor, instale com 'brew install cloudflared'"
    exit 1
fi

# Instalar depend√™ncias se necess√°rio
if [ ! -d "node_modules" ]; then
    echo "üì¶ Instalando depend√™ncias..."
    npm install
fi

# Nome do arquivo de log
LOG_FILE="./video_server.log"

# Verificar se j√° existe um servidor rodando
if pgrep -f "node video-share-stats.js" > /dev/null; then
    echo "‚ö†Ô∏è Servidor j√° est√° rodando. Deseja reiniciar? (s/n)"
    read -r answer
    if [[ "$answer" == "s" ]]; then
        echo "üîÑ Reiniciando servidor..."
        pkill -f "node video-share-stats.js"
        pkill -f "cloudflared tunnel"
        sleep 2
    else
        echo "‚úÖ Mantendo servidor atual."
        exit 0
    fi
fi

# Criar um arquivo LaunchAgent para manter o servidor rodando ap√≥s o logout
LAUNCH_AGENTS_DIR="$HOME/Library/LaunchAgents"
PLIST_FILE="$LAUNCH_AGENTS_DIR/com.video.share.plist"

if [ ! -d "$LAUNCH_AGENTS_DIR" ]; then
    mkdir -p "$LAUNCH_AGENTS_DIR"
fi

# Fun√ß√£o para criar o LaunchAgent
create_launch_agent() {
    echo "üìù Criando LaunchAgent para manter o servidor rodando..."
    
    # Preparar argumentos
    if [ -z "$MESSAGE" ]; then
        ARGS="\"$VIDEO_PATH\""
    else
        ARGS="\"$VIDEO_PATH\" \"$MESSAGE\""
    fi
    
    # Criar o arquivo plist
    cat > "$PLIST_FILE" << EOL
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>Label</key>
    <string>com.video.share</string>
    <key>ProgramArguments</key>
    <array>
        <string>/usr/local/bin/node</string>
        <string>${SCRIPT_DIR}/video-share-stats.js</string>
        <string>${VIDEO_PATH}</string>
EOL

    # Adicionar mensagem se existir
    if [ ! -z "$MESSAGE" ]; then
        cat >> "$PLIST_FILE" << EOL
        <string>${MESSAGE}</string>
EOL
    fi

    # Completar o arquivo plist
    cat >> "$PLIST_FILE" << EOL
    </array>
    <key>RunAtLoad</key>
    <true/>
    <key>KeepAlive</key>
    <true/>
    <key>WorkingDirectory</key>
    <string>${SCRIPT_DIR}</string>
    <key>StandardOutPath</key>
    <string>${SCRIPT_DIR}/video_server.log</string>
    <key>StandardErrorPath</key>
    <string>${SCRIPT_DIR}/video_server_error.log</string>
</dict>
</plist>
EOL

    # Carregar o LaunchAgent
    launchctl load "$PLIST_FILE"
    echo "‚úÖ LaunchAgent criado e carregado com sucesso!"
}

# Perguntar se deseja manter o servidor rodando ap√≥s sair
echo -e "\nüîÑ Como voc√™ deseja executar o servidor?"
echo "1) Executar no terminal atual (encerra quando fechar o terminal)"
echo "2) Executar em segundo plano (continua mesmo ap√≥s fechar o terminal)"
echo -n "Escolha (1/2): "
read -r choice

if [[ "$choice" == "2" ]]; then
    create_launch_agent
    echo -e "\nüöÄ Servidor iniciado em segundo plano!"
    echo "üìä Para ver os logs: tail -f $LOG_FILE"
    echo "‚èπÔ∏è  Para parar o servidor: launchctl unload $PLIST_FILE"
    echo -e "\n‚è≥ Aguarde um momento enquanto o servidor inicia..."
    sleep 5
    # Mostrar as primeiras linhas do log para ver a URL
    if [ -f "$SCRIPT_DIR/video_server.log" ]; then
        echo -e "\nüìã √öltimas linhas do log:"
        tail -20 "$SCRIPT_DIR/video_server.log" | grep -A 10 "URL para assistir"
    fi
else
    # Executar normalmente no terminal
    echo -e "\nüöÄ Iniciando servidor no terminal atual..."
    node video-share-stats.js "$VIDEO_PATH" "$MESSAGE"
fi
>>>>>>>video-share.js
#!/usr/bin/env node

const express = require('express');
const fs = require('fs');
const path = require('path');
const { exec, spawn } = require('child_process');
const QRCode = require('qrcode-terminal');
const mime = require('mime-types');

// Configura√ß√£o de debug
const DEBUG = true;
const debugLog = (message, ...args) => {
  if (DEBUG) {
    const timestamp = new Date().toISOString().split('T')[1].slice(0, -1);
    console.log(`[DEBUG ${timestamp}]`, message, ...args);
  }
};

// Verificar argumentos
if (process.argv.length < 3) {
  console.log('\n‚ùå Erro: Arquivo de v√≠deo n√£o especificado');
  console.log('\nUso: node video-share.js /caminho/para/arquivo.mp4 [mensagem personalizada]');
  console.log('Exemplo: node video-share.js ~/Videos/pascoa.mp4 "Feliz P√°scoa, filha! Com amor, papai."\n');
  process.exit(1);
}

// Obter caminho do v√≠deo e mensagem personalizada
const videoPath = path.resolve(process.argv[2]);
const customMessage = process.argv[3] || 'Feliz P√°scoa! Este v√≠deo especial foi enviado com muito carinho para voc√™!';

debugLog('Iniciando com v√≠deo:', videoPath);
debugLog('Mensagem personalizada:', customMessage);

// Verificar se o arquivo existe
if (!fs.existsSync(videoPath)) {
  console.log(`\n‚ùå Erro: O arquivo "${videoPath}" n√£o foi encontrado`);
  process.exit(1);
}

// Verificar se √© um v√≠deo
const mimeType = mime.lookup(videoPath);
if (!mimeType || !mimeType.startsWith('video/')) {
  console.log(`\n‚ùå Erro: O arquivo n√£o parece ser um v√≠deo (${mimeType || 'tipo desconhecido'})`);
  console.log('Por favor, forne√ßa um arquivo de v√≠deo (mp4, webm, etc.)');
  process.exit(1);
}

debugLog('Mime type do v√≠deo:', mimeType);

// Diret√≥rio para estat√≠sticas
const statsDir = path.join(process.cwd(), 'stats');
if (!fs.existsSync(statsDir)) {
  fs.mkdirSync(statsDir, { recursive: true });
  debugLog('Criado diret√≥rio de estat√≠sticas:', statsDir);
}

// Arquivo de estat√≠sticas
const statsFile = path.join(statsDir, 'access_stats.json');

// Carregar estat√≠sticas existentes ou criar novo objeto
let stats = { 
  videoName: path.basename(videoPath),
  totalViews: 0,
  firstView: null,
  lastView: null,
  viewDuration: [],
  viewDetails: []
};

if (fs.existsSync(statsFile)) {
  try {
    stats = JSON.parse(fs.readFileSync(statsFile, 'utf8'));
    debugLog('Estat√≠sticas carregadas:', { totalViews: stats.totalViews });
  } catch (error) {
    debugLog('Erro ao carregar estat√≠sticas, criando novo arquivo:', error);
  }
}

// Salvar estat√≠sticas em um arquivo
const saveStats = () => {
  fs.writeFileSync(statsFile, JSON.stringify(stats, null, 2));
  debugLog('Estat√≠sticas salvas');
};

// Iniciar servidor Express
const app = express();
const PORT = 3000;
const videoFileName = path.basename(videoPath);

// Armazenar sess√µes ativas
const activeSessions = {};

// P√°gina HTML para o player de v√≠deo com tema de P√°scoa e tracking
const playerHtml = `<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mensagem Especial de P√°scoa</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f5f5f5;
            color: #333;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            text-align: center;
            padding: 20px 0;
            position: relative;
        }
        
        .header h1 {
            color: #e74c3c;
            margin-bottom: 10px;
        }
        
        .message-box {
            background-color: white;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .video-container {
            background-color: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            text-align: center;
        }
        
        video {
            max-width: 100%;
            border-radius: 5px;
        }
        
        /* Decora√ß√µes de P√°scoa */
        .easter-decoration {
            position: absolute;
            width: 60px;
            height: 60px;
            background-repeat: no-repeat;
            background-size: contain;
            z-index: -1;
            opacity: 0.7;
        }
        
        .egg1 {
            top: -10px;
            left: 20px;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Cpath fill='%23FFD54F' d='M32,58c-13.3,0-24-15.1-24-34C8,12.3,18.7,6,32,6s24,6.3,24,18C56,42.9,45.3,58,32,58z'/%3E%3Cpath fill='%23FF7043' d='M31,15c0,0-3,2.3-3,4s1.3,3,3,3s3-1.3,3-3S31,15,31,15z'/%3E%3Cpath fill='%234CAF50' d='M40,24c0,0-4,3.3-4,6s1.8,5,4,5s4-2.3,4-5S40,24,40,24z'/%3E%3Cpath fill='%233F51B5' d='M25,30c0,0-3,2.3-3,4s1.3,3,3,3s3-1.3,3-3S25,30,25,30z'/%3E%3Cpath fill='%23E91E63' d='M32,38c0,0-4,3.3-4,6s1.8,5,4,5s4-2.3,4-5S32,38,32,38z'/%3E%3C/svg%3E");
        }
        
        .egg2 {
            top: 30px;
            right: 20px;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Cpath fill='%2381D4FA' d='M32,58c-13.3,0-24-15.1-24-34C8,12.3,18.7,6,32,6s24,6.3,24,18C56,42.9,45.3,58,32,58z'/%3E%3Cpath fill='%23FFEB3B' d='M25,18c0,0-2,1.8-2,3s0.9,2,2,2s2-0.8,2-2S25,18,25,18z'/%3E%3Cpath fill='%237E57C2' d='M42,20c0,0-3,2.3-3,4s1.3,3,3,3s3-1.3,3-3S42,20,42,20z'/%3E%3Cpath fill='%23FF5252' d='M24,36c0,0-2,1.8-2,3s0.9,2,2,2s2-0.8,2-2S24,36,24,36z'/%3E%3Cpath fill='%2326A69A' d='M38,40c0,0-2,1.3-2,3s0.9,3,2,3s2-1.3,2-3S38,40,38,40z'/%3E%3C/svg%3E");
        }
        
        .bunny {
            position: fixed;
            bottom: 10px;
            left: 10px;
            width: 80px;
            height: 80px;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Cpath fill='%23ECEFF1' d='M32,62c-8.8,0-16-7.2-16-16V26c0-8.8,7.2-16,16-16s16,7.2,16,16v20C48,54.8,40.8,62,32,62z'/%3E%3Cpath fill='%23FFCDD2' d='M38,42c0,3.3-2.7,6-6,6s-6-2.7-6-6s2.7-6,6-6S38,38.7,38,42z'/%3E%3Cpath fill='%23ECEFF1' d='M24,10c0,0-8-2-10,6s2,10,2,10s-10-2-12,4s4,8,4,8 M40,10c0,0,8-2,10,6s-2,10-2,10s10-2,12,4s-4,8-4,8'/%3E%3Ccircle fill='%23212121' cx='26' cy='36' r='2'/%3E%3Ccircle fill='%23212121' cx='38' cy='36' r='2'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-size: contain;
            animation: hop 5s infinite;
        }
        
        @keyframes hop {
            0%, 20%, 50%, 80%, 100% {
                transform: translateY(0);
            }
            40% {
                transform: translateY(-30px);
            }
            60% {
                transform: translateY(-15px);
            }
        }

        .error-message {
            color: red;
            padding: 10px;
            border: 1px solid red;
            background-color: #fee;
            margin-top: 20px;
            border-radius: 5px;
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="easter-decoration egg1"></div>
            <div class="easter-decoration egg2"></div>
            <h1>Mensagem Especial de P√°scoa</h1>
            <p>Algu√©m tem um v√≠deo especial para voc√™!</p>
        </div>
        
        <div class="message-box">
            <p>${customMessage}</p>
        </div>
        
        <div class="video-container">
            <video id="videoPlayer" controls autoplay>
                <source src="/video" type="${mimeType}">
                Seu navegador n√£o suporta v√≠deos HTML5.
            </video>
            <div id="errorMessage" class="error-message">
                Houve um erro ao carregar o v√≠deo. Por favor, tente novamente.
            </div>
        </div>
    </div>
    
    <div class="bunny"></div>

    <script>
        // Gerar um ID √∫nico para esta sess√£o
        const sessionId = Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
        
        // Registrar in√≠cio da visualiza√ß√£o
        fetch('/track/start', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ 
                sessionId,
                userAgent: navigator.userAgent,
                language: navigator.language,
                screenSize: \`\${window.screen.width}x\${window.screen.height}\`,
                timestamp: new Date().toISOString()
            }),
        })
        .catch(error => {
            console.error('Erro ao registrar in√≠cio da visualiza√ß√£o:', error);
        });

        // Registrar eventos do v√≠deo
        const videoPlayer = document.getElementById('videoPlayer');
        const errorMessage = document.getElementById('errorMessage');
        let startTime = new Date();
        let watchDuration = 0;
        let isPlaying = false;
        let heartbeatInterval;

        // Tratamento de erros do v√≠deo
        videoPlayer.addEventListener('error', () => {
            console.error('Erro ao carregar o v√≠deo:', videoPlayer.error);
            errorMessage.textContent = 'Erro ao carregar o v√≠deo: ' + (videoPlayer.error ? videoPlayer.error.message : 'Erro desconhecido');
            errorMessage.style.display = 'block';
            
            // Enviar erro para o servidor
            fetch('/track/error', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ 
                    sessionId,
                    errorCode: videoPlayer.error ? videoPlayer.error.code : 'unknown',
                    errorMessage: videoPlayer.error ? videoPlayer.error.message : 'Erro desconhecido'
                }),
            }).catch(err => console.error('Erro ao enviar relat√≥rio de erro:', err));
        });

        videoPlayer.addEventListener('play', () => {
            isPlaying = true;
            startTime = new Date();
            errorMessage.style.display = 'none';
            
            // Iniciar heartbeat para manter registro de que o usu√°rio est√° assistindo
            heartbeatInterval = setInterval(() => {
                if (isPlaying) {
                    watchDuration = (new Date() - startTime) / 1000;
                    fetch('/track/heartbeat', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ 
                            sessionId,
                            duration: watchDuration,
                            progress: videoPlayer.currentTime / videoPlayer.duration
                        }),
                    }).catch(err => console.error('Erro no heartbeat:', err));
                }
            }, 30000); // Heartbeat a cada 30 segundos
        });

        videoPlayer.addEventListener('pause', () => {
            isPlaying = false;
            const pauseTime = new Date();
            watchDuration += (pauseTime - startTime) / 1000;

            fetch('/track/pause', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ 
                    sessionId,
                    duration: watchDuration,
                    progress: videoPlayer.currentTime / videoPlayer.duration
                }),
            }).catch(err => console.error('Erro ao registrar pausa:', err));
        });

        videoPlayer.addEventListener('ended', () => {
            isPlaying = false;
            clearInterval(heartbeatInterval);
            const endTime = new Date();
            watchDuration += (endTime - startTime) / 1000;

            fetch('/track/complete', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ 
                    sessionId,
                    duration: watchDuration,
                    completed: true
                }),
            }).catch(err => console.error('Erro ao registrar conclus√£o do v√≠deo:', err));
        });

        // Registrar quando o usu√°rio sai da p√°gina
        window.addEventListener('beforeunload', () => {
            if (isPlaying) {
                const exitTime = new Date();
                watchDuration += (exitTime - startTime) / 1000;
            }
            
            // Usar sendBeacon para garantir que os dados sejam enviados
            navigator.sendBeacon('/track/exit', JSON.stringify({
                sessionId,
                duration: watchDuration,
                progress: videoPlayer.currentTime / videoPlayer.duration
            }));
            
            clearInterval(heartbeatInterval);
        });
    </script>
</body>
</html>
`;

// Middleware para processar JSON
app.use(express.json());

// Rota para a p√°gina principal
app.get('/', (req, res) => {
  // Registrar acesso
  const timestamp = new Date();
  if (!stats.firstView) {
    stats.firstView = timestamp;
  }
  stats.lastView = timestamp;
  stats.totalViews++;
  
  // Detalhes da visualiza√ß√£o
  const viewInfo = {
    timestamp: timestamp.toISOString(),
    ip: req.ip,
    userAgent: req.headers['user-agent'],
    referrer: req.headers.referer || 'direct',
    id: `view_${Date.now()}`
  };
  
  stats.viewDetails.push(viewInfo);
  saveStats();
  
  // Notificar no console
  console.log('\nüéâ Nova visita detectada!');
  console.log(`üìÖ Data e hora: ${timestamp.toLocaleString()}`);
  console.log(`üåê IP: ${req.ip}`);
  console.log(`üì± Dispositivo: ${req.headers['user-agent']}`);
  console.log(`\nüéØ Total de visitas: ${stats.totalViews}`);
  
  res.send(playerHtml);
});

// Rota para servir o v√≠deo
app.get('/video', (req, res) => {
  debugLog('Requisi√ß√£o de v√≠deo recebida', { ip: req.ip });
  
  // Obter tamanho do arquivo
  const stat = fs.statSync(videoPath);
  const fileSize = stat.size;
  const range = req.headers.range;

  // Suporte para streaming parcial do v√≠deo
  if (range) {
    debugLog('Requisi√ß√£o com range', { range });
    const parts = range.replace(/bytes=/, "").split("-");
    const start = parseInt(parts[0], 10);
    const end = parts[1] ? parseInt(parts[1], 10) : fileSize - 1;
    const chunksize = (end - start) + 1;
    
    try {
      const file = fs.createReadStream(videoPath, { start, end });
      
      res.writeHead(206, {
        'Content-Range': `bytes ${start}-${end}/${fileSize}`,
        'Accept-Ranges': 'bytes',
        'Content-Length': chunksize,
        'Content-Type': mimeType
      });
      
      debugLog('Enviando parcial do v√≠deo', { start, end, chunksize });
      file.pipe(res);
    } catch (error) {
      debugLog('Erro ao criar stream do v√≠deo com range', error);
      res.status(500).send('Erro ao processar v√≠deo');
    }
  } else {
    // Streaming completo do v√≠deo
    try {
      res.writeHead(200, {
        'Content-Length': fileSize,
        'Content-Type': mimeType
      });
      
      debugLog('Enviando v√≠deo completo', { fileSize });
      fs.createReadStream(videoPath).pipe(res);
    } catch (error) {
      debugLog('Erro ao criar stream do v√≠deo completo', error);
      res.status(500).send('Erro ao processar v√≠deo');
    }
  }
});

// Endpoint para registro de erros do cliente
app.post('/track/error', (req, res) => {
  const { sessionId, errorCode, errorMessage } = req.body;
  debugLog('Erro reportado pelo cliente', { sessionId, errorCode, errorMessage });
  res.status(200).send('OK');
});

// Endpoint para rastrear o in√≠cio da visualiza√ß√£o
app.post('/track/start', (req, res) => {
  const { sessionId, userAgent, language, screenSize, timestamp } = req.body;
  
  activeSessions[sessionId] = {
    start: new Date(),
    lastActive: new Date(),
    userAgent,
    language,
    screenSize,
    ip: req.ip,
    duration: 0,
    progress: 0,
    completed: false
  };
  
  console.log(`\n‚ñ∂Ô∏è Visualiza√ß√£o iniciada! Sess√£o: ${sessionId}`);
  console.log(`üì± Dispositivo: ${userAgent}`);
  console.log(`üåê IP: ${req.ip}`);
  
  res.status(200).send('OK');
});

// Heartbeat para saber se o usu√°rio ainda est√° assistindo
app.post('/track/heartbeat', (req, res) => {
  const { sessionId, duration, progress } = req.body;
  
  if (activeSessions[sessionId]) {
    activeSessions[sessionId].lastActive = new Date();
    activeSessions[sessionId].duration = duration;
    activeSessions[sessionId].progress = progress;
    
    debugLog(`Heartbeat da sess√£o ${sessionId}`, { progress: Math.round(progress * 100) + '%' });
  }
  
  res.status(200).send('OK');
});

// Pausa no v√≠deo
app.post('/track/pause', (req, res) => {
  const { sessionId, duration, progress } = req.body;
  
  if (activeSessions[sessionId]) {
    activeSessions[sessionId].lastActive = new Date();
    activeSessions[sessionId].duration = duration;
    activeSessions[sessionId].progress = progress;
    
    debugLog(`V√≠deo pausado na sess√£o ${sessionId}`, { progress: Math.round(progress * 100) + '%' });
  }
  
  res.status(200).send('OK');
});

// V√≠deo completado
app.post('/track/complete', (req, res) => {
  const { sessionId, duration, completed } = req.body;
  
  if (activeSessions[sessionId]) {
    const session = activeSessions[sessionId];
    session.lastActive = new Date();
    session.duration = duration;
    session.progress = 1;
    session.completed = completed;
    
    // Adicionar √†s estat√≠sticas
    stats.viewDuration.push({
      sessionId,
      duration,
      completed: true,
      timestamp: new Date().toISOString(),
      device: session.userAgent
    });
    
    saveStats();
    
    console.log(`\n‚úÖ V√≠deo completado! Sess√£o: ${sessionId}`);
    console.log(`‚è±Ô∏è Tempo de visualiza√ß√£o: ${Math.round(duration)} segundos`);
  }
  
  res.status(200).send('OK');
});

// Sa√≠da da p√°gina
app.post('/track/exit', (req, res) => {
  let bodyData = '';
  
  req.on('data', chunk => {
    bodyData += chunk.toString();
  });
  
  req.on('end', () => {
    try {
      const { sessionId, duration, progress } = JSON.parse(bodyData);
      
      if (activeSessions[sessionId]) {
        const session = activeSessions[sessionId];
        
        // Adicionar √†s estat√≠sticas
        stats.viewDuration.push({
          sessionId,
          duration,
          progress,
          completed: progress >= 0.9, // Considerar completo se assistiu 90%
          timestamp: new Date().toISOString(),
          device: session.userAgent
        });
        
        saveStats();
        
        console.log(`\nüëã Usu√°rio saiu! Sess√£o: ${sessionId}`);
        console.log(`‚è±Ô∏è Tempo total de visualiza√ß√£o: ${Math.round(duration)} segundos`);
        console.log(`üìä Progresso: ${Math.round(progress * 100)}%`);
        
        // Remover a sess√£o
        delete activeSessions[sessionId];
      }
    } catch (error) {
      debugLog('Erro ao processar dados de sa√≠da', error);
    }
  });
  
  // Sempre responder com sucesso para sendBeacon
  res.status(200).send('OK');
});

// Endpoint para ver estat√≠sticas (protegido)
app.get('/stats', (req, res) => {
  res.json({
    stats,
    activeSessions: Object.keys(activeSessions).length
  });
});

// Iniciar o servidor
const server = app.listen(PORT, () => {
  console.log(`\nüöÄ Servidor local iniciado em http://localhost:${PORT}`);
  console.log(`üìπ Compartilhando v√≠deo: ${videoFileName}`);
  console.log(`üìù Com a mensagem: "${customMessage}"`);

  // Verificar se cloudflared est√° instalado
  const whichProcess = exec('which cloudflared', (error, stdout, stderr) => {
    if (error || !stdout || stderr.includes('not found')) {
      console.log('\n‚ùå Cloudflared n√£o encontrado ou erro ao verificar.');
      console.log('   Verifique se est√° instalado e no PATH do sistema.');
      console.log('   Instale com:');
      console.log('   Ubuntu/Debian: sudo apt install cloudflared');
      console.log('   macOS: brew install cloudflared');
      console.log('   Windows: Baixe de https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup/installation/');
      console.error('Erro detalhado:', error || stderr);
      process.exit(1);
    }

    debugLog('Cloudflared encontrado em:', stdout.trim());

    // Iniciar o t√∫nel Cloudflare
    console.log('\n‚è≥ Iniciando t√∫nel Cloudflare... Isso pode levar alguns segundos.');
    console.log('   (Procurando pela URL p√∫blica...)');

    let tunnelReady = false;
    let publicUrl = null;
    let tunnelProcess = null;

    // Usar spawn em vez de exec para melhor controle do processo
    try {
      debugLog('Iniciando processo cloudflared...');
      
      // Op√ß√µes para o spawn
      const options = {
        shell: true,
        stdio: ['pipe', 'pipe', 'pipe']
      };
      
      // Iniciar processo com spawn para melhor controle
      tunnelProcess = spawn('cloudflared', ['tunnel', '--url', `http://localhost:${PORT}`, '--no-autoupdate'], options);
      
      debugLog('Processo cloudflared iniciado com PID:', tunnelProcess.pid);
      
      // Armazenar o PID para encerramento posterior
      process.env.CLOUDFLARED_PID = tunnelProcess.pid;
      
      // Fun√ß√£o para exibir a URL e QR Code
      const displayTunnelInfo = () => {
        console.log('\n' + '='.repeat(60));
        console.log('üéâ T√öNEL PRONTO! SEU V√çDEO EST√Å ACESS√çVEL NA INTERNET!');
        console.log('='.repeat(60));
        console.log('\nüîó URL P√∫blica para Compartilhar:');
        console.log(`\n   >>> ${publicUrl} <<< \n`);
        
        // Gerar QR Code
        console.log('üì± QR Code (escaneie para acessar no celular):');
        QRCode.generate(publicUrl, { small: true });
        
        console.log('\nüìä Estat√≠sticas (visite esta URL no navegador):');
        console.log(`   ${publicUrl}/stats`);
        
        console.log('\n‚ö†Ô∏è Importante: O link acima funciona SOMENTE enquanto este programa estiver rodando.');
        console.log('   Seu computador precisa permanecer ligado e conectado √† internet.');
        console.log('\n   Pressione Ctrl+C aqui no terminal para encerrar.');
        console.log('='.repeat(60) + '\n');
      };
      
      // Processar sa√≠da do cloudflared
      tunnelProcess.stdout.on('data', (data) => {
        const output = data.toString();
        
        // Usar um log mais detalhado para depura√ß√£o
        debugLog('[cloudflared stdout]:', output.trim());
        
        // Se j√° encontramos a URL, n√£o precisamos continuar
        if (publicUrl) {
          return;
        }
        
        // Procurar pela URL usando regex
        const match = output.match(/(https:\/\/[a-z0-9-]+\.trycloudflare\.com)/);
        if (match) {
          publicUrl = match[0];
          tunnelReady = true;
          debugLog('URL do t√∫nel encontrada:', publicUrl);
          displayTunnelInfo();
        }
      });
      
      // Processar erros do cloudflared
      tunnelProcess.stderr.on('data', (data) => {
        const errorOutput = data.toString().trim();
        
        // Filtrar mensagens informativas (n√£o erros)
        if (errorOutput.includes('ERR') && !errorOutput.includes('INF') && !errorOutput.includes('WRN')) {
          console.error(`\n‚ÄºÔ∏è [cloudflared ERRO]: ${errorOutput}`);
        } else {
          // Log de mensagens informativas para depura√ß√£o
          debugLog('[cloudflared stderr]:', errorOutput);
        }
      });
      
      // Lidar com o encerramento do processo cloudflared
      tunnelProcess.on('close', (code) => {
        debugLog(`Processo cloudflared encerrado com c√≥digo ${code}`);
        
        if (!tunnelReady && code !== 0) {
          console.error('\n‚ùå O t√∫nel foi encerrado inesperadamente ANTES de obter a URL p√∫blica.');
          console.error('\n‚ùå O t√∫nel foi encerrado inesperadamente ANTES de obter a URL p√∫blica.');
          console.error('   Poss√≠veis problemas:');
          console.error('   1. Conex√£o com a internet inst√°vel ou restrita');
          console.error('   2. Firewall bloqueando a conex√£o do cloudflared');
          console.error('   3. Vers√£o desatualizada do cloudflared');
          console.error('   4. Cloudflare pode estar com problemas tempor√°rios');
          console.error('\n   Tente executar manualmente: cloudflared tunnel --url http://localhost:3000');
          console.error('   para ver mensagens de erro mais detalhadas.');
        } else if (code !== 0) {
          console.warn('\n‚ö†Ô∏è O t√∫nel Cloudflared foi encerrado com c√≥digo de erro:', code);
          console.warn('   O servi√ßo de compartilhamento n√£o est√° mais dispon√≠vel.');
        }
        
        // Tentar reiniciar automaticamente em caso de falha?
        if (code !== 0 && !process.env.TUNNEL_RESTART_ATTEMPTED) {
          process.env.TUNNEL_RESTART_ATTEMPTED = "true";
          console.log('\nüîÑ Tentando reiniciar o t√∫nel automaticamente...');
          
          // Implementar rein√≠cio com m√©todo alternativo
          try {
            debugLog('Tentando m√©todo alternativo para o t√∫nel...');
            
            // Usar um m√©todo alternativo: cloudflared http
            const alternativeTunnel = spawn('cloudflared', ['tunnel', 'http', `http://localhost:${PORT}`], {
              shell: true,
              stdio: ['pipe', 'pipe', 'pipe']
            });
            
            process.env.CLOUDFLARED_ALT_PID = alternativeTunnel.pid;
            
            alternativeTunnel.stdout.on('data', (data) => {
              const output = data.toString();
              debugLog('[alternativeTunnel stdout]:', output.trim());
              
              // Tentar encontrar URL no formato diferente
              const altMatch = output.match(/(https:\/\/[a-z0-9-]+\.trycloudflare\.com)/);
              if (altMatch && !publicUrl) {
                publicUrl = altMatch[0];
                tunnelReady = true;
                console.log('\n‚úÖ Conex√£o estabelecida usando m√©todo alternativo!');
                displayTunnelInfo();
              }
            });
            
            alternativeTunnel.stderr.on('data', (data) => {
              debugLog('[alternativeTunnel stderr]:', data.toString().trim());
            });
            
          } catch (e) {
            console.error('Falha ao tentar m√©todo alternativo:', e);
          }
        }
      });
      
      // Configurar timeout para verificar se a URL n√£o foi encontrada ap√≥s um tempo
      setTimeout(() => {
        if (!publicUrl) {
          debugLog('Timeout: URL do t√∫nel n√£o encontrada ap√≥s 60 segundos');
          console.warn('\n‚ö†Ô∏è N√£o foi poss√≠vel obter a URL do t√∫nel ap√≥s 60 segundos.');
          console.warn('   Isso pode indicar problemas com o Cloudflare ou com sua conex√£o.');
          console.warn('   O servidor local ainda est√° rodando em: http://localhost:3000');
          
          // Verificar status do processo
          if (tunnelProcess && tunnelProcess.pid) {
            try {
              // No Unix, enviar sinal 0 verifica se o processo existe sem afet√°-lo
              process.kill(tunnelProcess.pid, 0);
              console.warn('   O processo cloudflared ainda est√° rodando (PID:', tunnelProcess.pid, ')');
              console.warn('   Verificando estado do processo...');
              
              // Em sistemas Unix, podemos verificar se o processo est√° "zombie"
              if (process.platform !== 'win32') {
                exec(`ps -p ${tunnelProcess.pid} -o state`, (err, stdout) => {
                  if (!err) {
                    debugLog('Estado do processo:', stdout.trim());
                    if (stdout.includes('Z')) {
                      console.warn('   O processo est√° em estado "zombie" - n√£o est√° funcionando corretamente.');
                    }
                  }
                });
              }
            } catch (e) {
              console.warn('   O processo cloudflared parece ter terminado sem notificar.');
            }
          }
          
          console.warn('\nüí° Sugest√µes:');
          console.warn('   1. Verifique se o cloudflared est√° na vers√£o mais recente');
          console.warn('   2. Tente reiniciar o programa');
          console.warn('   3. Verifique sua conex√£o com a internet');
          console.warn('   4. Tente usar outro m√©todo de compartilhamento, como ngrok');
          
          // Oferecer op√ß√£o de tentar m√©todo alternativo
          console.warn('\n   Deseja tentar um m√©todo alternativo? Execute ctrl+C e depois:');
          console.warn('   node video-share.js /caminho/do/video.mp4 "Mensagem" --alt-tunnel');
        }
      }, 60000);
      
    } catch (execError) {
      console.error('\n‚ùå Falha cr√≠tica ao tentar iniciar o processo cloudflared:', execError);
      console.error('   Verifique se o cloudflared est√° corretamente instalado.');
      
      // Verificar instala√ß√£o
      exec('cloudflared --version', (err, stdout, stderr) => {
        if (err) {
          console.error('   N√£o foi poss√≠vel verificar a vers√£o do cloudflared:', err.message);
        } else {
          console.error('   Vers√£o do cloudflared:', stdout.trim());
        }
      });
      
      // Continuar com o servidor local
      console.log('\n‚ö†Ô∏è Continuando apenas com servidor local em: http://localhost:3000');
    }
  });
});

// Encerrar graciosamente ao receber Ctrl+C
process.on('SIGINT', () => {
  console.log('\n\nüëã Recebido Ctrl+C. Encerrando servidor e t√∫nel...');
  
  // Salvar estat√≠sticas
  saveStats();
  debugLog('Estat√≠sticas salvas antes de encerrar');

  // Tentar encerrar o processo cloudflared
  const tryKillProcess = (pid, name) => {
    if (pid) {
      try {
        debugLog(`Tentando encerrar processo ${name} (PID: ${pid})`);
        // Enviar SIGTERM primeiro
        process.kill(parseInt(pid, 10), 'SIGTERM');
        return true;
      } catch (e) {
        debugLog(`Erro ao encerrar ${name} (PID: ${pid}):`, e.message);
        try {
          // Tentar com SIGKILL se necess√°rio
          process.kill(parseInt(pid, 10), 'SIGKILL');
          return true;
        } catch (e2) {
          debugLog(`Falha tamb√©m com SIGKILL para ${name}:`, e2.message);
          return false;
        }
      }
    }
    return false;
  };

  // Tentar encerrar processos do cloudflared
  let pidKilled = false;
  
  // Tentar o processo principal
  if (process.env.CLOUDFLARED_PID) {
    pidKilled = tryKillProcess(process.env.CLOUDFLARED_PID, 'cloudflared') || pidKilled;
  }
  
  // Tentar o processo alternativo se existir
  if (process.env.CLOUDFLARED_ALT_PID) {
    pidKilled = tryKillProcess(process.env.CLOUDFLARED_ALT_PID, 'cloudflared alternativo') || pidKilled;
  }
  
  if (!pidKilled) {
    debugLog('Nenhum processo cloudflared foi encerrado, tentando matar por nome...');
    
    // Em sistemas Unix, podemos tentar matar por nome
    if (process.platform !== 'win32') {
      exec('pkill -f "cloudflared tunnel"', (err) => {
        if (err) {
          debugLog('Erro ao tentar matar cloudflared por nome:', err);
        } else {
          debugLog('Comando para matar cloudflared por nome executado');
        }
      });
    } else {
      // No Windows, usar taskkill
      exec('taskkill /F /IM cloudflared.exe', (err) => {
        if (err) {
          debugLog('Erro ao tentar matar cloudflared no Windows:', err);
        } else {
          debugLog('Comando taskkill para cloudflared executado');
        }
      });
    }
  }

  // Fechar o servidor Express
  server.close((err) => {
    if (err) {
      console.error("‚ùå Erro ao fechar o servidor Express:", err);
      process.exit(1);
    }
    console.log('‚úÖ Servidor web local encerrado com sucesso.');
    process.exit(0);
  });

  // Adiciona um timeout para for√ßar a sa√≠da se algo travar
  setTimeout(() => {
    debugLog('Timeout de encerramento atingido, for√ßando sa√≠da');
    console.error('‚ùå Servidor ou t√∫nel n√£o encerraram a tempo. For√ßando sa√≠da.');
    process.exit(1);
  }, 5000);
});

// Tratamento de erros n√£o capturados
process.on('uncaughtException', (error) => {
  console.error('\n‚ùå Erro n√£o capturado:', error);
  debugLog('Stack trace:', error.stack);
  
  // Salvar estat√≠sticas em caso de erro
  try {
    saveStats();
  } catch (e) {
    debugLog('Erro ao salvar estat√≠sticas durante exce√ß√£o:', e);
  }
  
  // Continuar executando
  console.log('\n‚ö†Ô∏è O servidor continuar√° em execu√ß√£o apesar do erro.');
});

// Implementar verifica√ß√£o cont√≠nua de estado do t√∫nel
const tunnelCheckInterval = setInterval(() => {
  const pid = process.env.CLOUDFLARED_PID || process.env.CLOUDFLARED_ALT_PID;
  
  if (pid && process.platform !== 'win32') {
    exec(`ps -p ${pid} -o state`, (err, stdout) => {
      if (err) {
        debugLog('Processo cloudflared n√£o encontrado no intervalo de verifica√ß√£o');
        clearInterval(tunnelCheckInterval);
      } else {
        // Se encontrarmos algo estranho no estado, registrar
        if (!stdout.includes('S') && !stdout.includes('R')) {
          debugLog('Estado incomum do processo cloudflared:', stdout.trim());
        }
      }
    });
  }
}, 30000);

// Log de finaliza√ß√£o da inicializa√ß√£o
debugLog('Inicializa√ß√£o completa');
